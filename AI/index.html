<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Quentin Nichols AI</title>
  <meta name="description" content="A private, local-first chat experience grounded in Quentin Nichols' writing and work.">
  <link rel="stylesheet" href="/style.css">
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-ESFM9WKBF9"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-ESFM9WKBF9');
  </script>
</head>
<body class="ai-page">
  <nav class="site-nav" aria-label="Site">
    <div class="nav-shell">
      <details class="nav-menu">
        <summary aria-label="Open menu">
          <span></span>
          <span></span>
          <span></span>
        </summary>
        <div class="nav-menu-panel">
          <a href="/">Home</a>
          <a href="/photography/">Photography</a>
          <a href="/projects/">Projects</a>
          <a href="/blog/">Blog</a>
          <a href="/contact/">Contact</a>
          <a href="https://shop.quentinnichols.com/" target="_blank" rel="noopener">Shop</a>
        </div>
      </details>
      <a class="nav-logo" href="/">
        <img src="/assets/Watermark (1) copy.png" alt="Quentin Nichols Oregon">
      </a>
      <div class="nav-spacer" aria-hidden="true"></div>
    </div>
  </nav>

  <main class="ai-main">
    <section class="ai-hero">
      <div class="ai-inner">
        <div class="ai-title-wrap">
          <p class="ai-kicker">Quentin Nichols</p>
          <h1 class="ai-title">AI Studio</h1>
          <p class="ai-subtitle">
            A private, local-first chat experience grounded in the writing, photography, and projects on this site.
            Use it to connect themes, find stories, or revisit moments.
          </p>
        </div>
      </div>
    </section>

    <section class="ai-chat" aria-label="AI chat">
      <div class="ai-inner">
        <div class="ai-mobile-intro">
          <p class="ai-subtitle">
            Open the AI chat for a focused, full-screen experience with your chat history and message input.
          </p>
          <button class="ai-open" type="button" id="open-chat">Open AI</button>
        </div>
        <div class="ai-card">
          <div class="ai-toolbar">
            <div class="ai-status-wrap">
              <span class="ai-status">Memory: saved on this device</span>
              <span class="ai-status ai-status--dot">Live answers</span>
            </div>
            <div class="ai-toolbar-actions">
              <button class="ai-clear" type="button" id="clear-chat">Clear chat</button>
              <button class="ai-close" type="button" id="close-chat" aria-label="Close AI chat">Close</button>
            </div>
          </div>

          <div class="ai-log" id="chat-log" aria-live="polite"></div>

          <form class="ai-input" id="chat-form">
            <label class="ai-label" for="chat-message">Ask about posts, photography, or reflections</label>
            <div class="ai-input-row">
              <textarea id="chat-message" rows="2" placeholder="What themes keep showing up in my writing?" required></textarea>
              <button type="submit">Send</button>
            </div>
            <p class="ai-hint">Your messages stay on this device. Responses are generated on-demand.</p>
          </form>
        </div>
      </div>
    </section>
  </main>

  <script>
    const STORAGE_KEY = "qjn_ai_chat";
    const log = document.getElementById("chat-log");
    const form = document.getElementById("chat-form");
    const input = document.getElementById("chat-message");
    const clearBtn = document.getElementById("clear-chat");

    function createLinkedText(text) {
      const container = document.createElement("span");
      const markdownLink = /\[([^\]]+)\]\((https?:\/\/[^\s)]+|\/[^\s)]+)\)/g;
      const urlPattern = /\bhttps?:\/\/[^\s]+/g;

      let lastIndex = 0;
      let match;

      while ((match = markdownLink.exec(text)) !== null) {
        const [full, label, href] = match;
        if (match.index > lastIndex) {
          container.appendChild(document.createTextNode(text.slice(lastIndex, match.index)));
        }

        const link = document.createElement("a");
        link.href = href;
        link.textContent = label;
        if (/^https?:\/\//i.test(href)) {
          link.rel = "noopener";
          link.target = "_blank";
        }
        container.appendChild(link);
        lastIndex = match.index + full.length;
      }

      if (lastIndex < text.length) {
        container.appendChild(document.createTextNode(text.slice(lastIndex)));
      }

      const childNodes = Array.from(container.childNodes);
      container.textContent = "";
      childNodes.forEach((node) => {
        if (node.nodeType === Node.TEXT_NODE) {
          const parts = node.textContent.split(urlPattern);
          const matches = node.textContent.match(urlPattern) || [];
          parts.forEach((part, idx) => {
            if (part) container.appendChild(document.createTextNode(part));
            const url = matches[idx];
            if (url) {
              const link = document.createElement("a");
              link.href = url;
              link.textContent = "link";
              link.rel = "noopener";
              link.target = "_blank";
              container.appendChild(link);
            }
          });
        } else {
          container.appendChild(node);
        }
      });

      return container;
    }

    function cleanForSpeech(text) {
      const withoutMarkdownLinks = text.replace(/\[([^\]]+)\]\((https?:\/\/[^\s)]+|\/[^\s)]+)\)/g, "$1");
      const withoutUrls = withoutMarkdownLinks.replace(/\bhttps?:\/\/[^\s]+/g, "");
      const expandAges = withoutUrls.replace(/\b(\d+)-year-old\b/gi, "$1 year old");
      const softHyphens = expandAges.replace(/(\d)-(\d)/g, "$1 to $2");
      return softHyphens.replace(/\s+/g, " ").trim();
    }

    function render(messages) {
      log.innerHTML = "";
      messages.forEach((msg, index) => {
        const row = document.createElement("div");
        row.className = `ai-bubble ai-bubble--${msg.role}`;
        const textEl = document.createElement("p");
        textEl.className = "ai-bubble-text";
        if (msg.role === "assistant" && msg.text && msg.text !== "Thinking...") {
          textEl.appendChild(createLinkedText(msg.text));
        } else {
          textEl.textContent = msg.text;
        }
        row.appendChild(textEl);

        if (msg.role === "assistant" && msg.text && msg.text !== "Thinking...") {
          const controls = document.createElement("div");
          controls.className = "ai-bubble-controls";
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "ai-tts";
          btn.dataset.index = String(index);
          btn.textContent = "Listen";
          const stopBtn = document.createElement("button");
          stopBtn.type = "button";
          stopBtn.className = "ai-tts-stop";
          stopBtn.dataset.index = String(index);
          stopBtn.textContent = "Stop";
          stopBtn.hidden = true;
          const progress = document.createElement("progress");
          progress.className = "ai-tts-progress";
          progress.max = 1;
          progress.value = 0;
          progress.hidden = true;

          controls.appendChild(btn);
          controls.appendChild(stopBtn);
          controls.appendChild(progress);
          row.appendChild(controls);
        }

        log.appendChild(row);
      });
      log.scrollTop = log.scrollHeight;
    }

    function loadMessages() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        return raw ? JSON.parse(raw) : [];
      } catch (e) {
        return [];
      }
    }

    function saveMessages(messages) {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(messages));
    }

    const messages = loadMessages();
    render(messages);

    async function sendMessage(payloadMessages) {
      const response = await fetch("/api/ask", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ messages: payloadMessages }),
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(errorText || "Request failed");
      }

      const data = await response.json();
      return data.reply || "Sorry, I couldn't generate a response.";
    }

    const openBtn = document.getElementById("open-chat");
    const closeBtn = document.getElementById("close-chat");

    if (openBtn) {
      openBtn.addEventListener("click", () => {
        document.body.classList.add("ai-chat-open");
        setTimeout(() => {
          input.focus();
          input.scrollIntoView({ behavior: "smooth", block: "center" });
        }, 150);
      });
    }

    if (closeBtn) {
      closeBtn.addEventListener("click", () => {
        document.body.classList.remove("ai-chat-open");
      });
    }

    input.addEventListener("focus", () => {
      document.body.classList.add("ai-chat-open");
      setTimeout(() => {
        input.scrollIntoView({ behavior: "smooth", block: "center" });
      }, 150);
    });

    async function requestSpeech(text, signal) {
      const response = await fetch("/api/tts", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ text: cleanForSpeech(text) }),
        signal,
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(errorText || "TTS request failed");
      }

      const blob = await response.blob();
      return URL.createObjectURL(blob);
    }

    let activePlayback = null;

    function playSpeechQueue(text, controls) {
      const cleaned = cleanForSpeech(text);
      if (!cleaned) return null;
      const maxChunk = 1100;
      const sentences = cleaned.match(/[^.!?]+[.!?]*/g) || [cleaned];
      const chunks = [];
      let buffer = "";
      let stopped = false;
      let currentAudio = null;
      let currentUrl = null;
      let currentFetch = null;
      let nextFetch = null;

      function flushBuffer(nextText) {
        if ((buffer + nextText).length <= maxChunk) {
          buffer += nextText;
          return;
        }
        if (buffer) chunks.push(buffer.trim());
        buffer = nextText;
      }

      function splitByComma(sentence) {
        const parts = sentence.split(/(,\s+|;\s+|:\s+)/);
        let acc = "";
        for (let i = 0; i < parts.length; i += 2) {
          const segment = parts[i] || "";
          const punctuation = parts[i + 1] || "";
          const piece = `${segment}${punctuation}`;
          if (!piece.trim()) continue;
          if (piece.length > maxChunk) {
            const words = piece.split(/\s+/);
            let wordBuf = "";
            words.forEach((word) => {
              const next = wordBuf ? `${wordBuf} ${word}` : word;
              if (next.length > maxChunk) {
                if (wordBuf) chunks.push(wordBuf.trim());
                wordBuf = word;
              } else {
                wordBuf = next;
              }
            });
            if (wordBuf) chunks.push(wordBuf.trim());
          } else {
            flushBuffer(piece);
          }
        }
      }

      sentences.forEach((sentence) => {
        if (sentence.length > maxChunk) {
          splitByComma(sentence);
        } else {
          flushBuffer(sentence);
        }
      });
      if (buffer) chunks.push(buffer.trim());

      const stop = () => {
        stopped = true;
        if (currentFetch?.abort) currentFetch.abort();
        if (nextFetch?.abort) nextFetch.abort();
        currentFetch = null;
        nextFetch = null;
        if (currentAudio) {
          currentAudio.pause();
          currentAudio.currentTime = 0;
        }
        if (currentUrl) {
          URL.revokeObjectURL(currentUrl);
          currentUrl = null;
        }
        controls.listen.textContent = "Listen";
        controls.stop.hidden = true;
        controls.progress.hidden = true;
        controls.progress.value = 0;
      };

      controls.listen.textContent = "Playing";
      controls.stop.hidden = false;
      controls.progress.hidden = false;

      (async () => {
        const startFetch = (chunk) => {
          const controller = new AbortController();
          return {
            abort: () => controller.abort(),
            promise: requestSpeech(chunk, controller.signal),
          };
        };

        let index = 0;
        if (chunks.length > 0) {
          currentFetch = startFetch(chunks[0]);
        }

        while (!stopped && index < chunks.length && currentFetch) {
          let audioUrl;
          try {
            audioUrl = await currentFetch.promise;
          } catch (err) {
            if (stopped) break;
            throw err;
          }

          if (stopped) {
            URL.revokeObjectURL(audioUrl);
            break;
          }

          if (index + 1 < chunks.length) {
            nextFetch = startFetch(chunks[index + 1]);
          }

          currentUrl = audioUrl;
          await new Promise((resolve, reject) => {
            const audio = new Audio(audioUrl);
            currentAudio = audio;
            const onTimeUpdate = () => {
              if (Number.isFinite(audio.duration) && audio.duration > 0) {
                controls.progress.value = audio.currentTime / audio.duration;
              }
            };
            const cleanup = () => {
              audio.removeEventListener("timeupdate", onTimeUpdate);
              URL.revokeObjectURL(audioUrl);
              controls.progress.value = 0;
              currentAudio = null;
              currentUrl = null;
            };
            audio.addEventListener("timeupdate", onTimeUpdate);
            audio.addEventListener("ended", () => {
              cleanup();
              resolve();
            });
            audio.addEventListener("error", () => {
              cleanup();
              reject(new Error("Audio playback failed"));
            });
            audio.play().catch(reject);
          });

          currentFetch = nextFetch;
          nextFetch = null;
          index += 1;
        }
      })()
        .catch(() => {})
        .finally(() => {
          stop();
        });

      return { stop };
    }

    log.addEventListener("click", async (event) => {
      const btn = event.target.closest(".ai-tts");
      if (!btn) return;
      const index = Number(btn.dataset.index);
      const msg = messages[index];
      if (!msg || msg.role !== "assistant") return;

      if (activePlayback) {
        activePlayback.stop();
        activePlayback = null;
      }

      const controls = {
        listen: btn,
        stop: btn.parentElement.querySelector(".ai-tts-stop"),
        progress: btn.parentElement.querySelector(".ai-tts-progress"),
      };

      btn.disabled = true;
      btn.textContent = "Loading...";
      try {
        btn.textContent = "Playing";
        activePlayback = playSpeechQueue(msg.text, controls);
      } catch (err) {
        btn.textContent = "Listen";
      } finally {
        btn.disabled = false;
      }
    });

    log.addEventListener("click", (event) => {
      const stopBtn = event.target.closest(".ai-tts-stop");
      if (!stopBtn) return;
      if (activePlayback) {
        activePlayback.stop();
        activePlayback = null;
      }
    });

    form.addEventListener("submit", async (event) => {
      event.preventDefault();
      const text = input.value.trim();
      if (!text) return;
      document.body.classList.add("ai-chat-open");
      messages.push({ role: "user", text });
      const payloadMessages = messages.map((msg) => ({
        role: msg.role,
        content: msg.text,
      }));
      const pendingIndex = messages.push({ role: "assistant", text: "Thinking..." }) - 1;
      render(messages);
      saveMessages(messages);
      input.value = "";
      input.focus();

      try {
        const reply = await sendMessage(payloadMessages);
        messages[pendingIndex].text = reply;
      } catch (err) {
        messages[pendingIndex].text = "Sorry, something went wrong. Please try again.";
      }

      render(messages);
      saveMessages(messages);
    });

    clearBtn.addEventListener("click", () => {
      if (!confirm("Clear this chat from your device?")) return;
      messages.length = 0;
      saveMessages(messages);
      render(messages);
    });
  </script>
  <script src="/assets/nav.js"></script>
</body>
</html>
