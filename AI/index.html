<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Quentin Nichols AI</title>
  <meta name="description" content="A private, local-first chat experience grounded in Quentin Nichols' writing and work.">
  <link rel="stylesheet" href="/style.css">
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-ESFM9WKBF9"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-ESFM9WKBF9');
  </script>
</head>
<body class="ai-page">
  <nav class="site-nav" aria-label="Site">
    <div class="nav-shell">
      <details class="nav-menu">
        <summary aria-label="Open menu">
          <span></span>
          <span></span>
          <span></span>
        </summary>
        <div class="nav-menu-panel">
          <a href="/">Home</a>
          <a href="/photography/">Photography</a>
          <a href="/projects/">Projects</a>
          <a href="/blog/">Blog</a>
          <a href="/contact/">Contact</a>
          <a href="https://shop.quentinnichols.com/" target="_blank" rel="noopener">Shop</a>
        </div>
      </details>
      <a class="nav-logo" href="/">
        <img src="/assets/Watermark (1) copy.png" alt="Quentin Nichols Oregon">
      </a>
      <div class="nav-spacer" aria-hidden="true"></div>
    </div>
  </nav>

  <main class="ai-main">
    <section class="ai-hero">
      <div class="ai-inner">
        <div class="ai-title-wrap">
          <p class="ai-kicker">Quentin Nichols</p>
          <h1 class="ai-title">AI Studio</h1>
          <p class="ai-subtitle">
            A private, local-first chat experience grounded in the writing, photography, and projects on this site.
            Use it to connect themes, find stories, or revisit moments.
          </p>
        </div>
      </div>
    </section>

    <section class="ai-chat" aria-label="AI chat">
      <div class="ai-inner">
        <div class="ai-mobile-intro">
          <p class="ai-subtitle">
            Open the AI chat for a focused, full-screen experience with your chat history and message input.
          </p>
          <button class="ai-open" type="button" id="open-chat">Open AI</button>
        </div>
        <div class="ai-card">
          <div class="ai-toolbar">
            <div class="ai-status-wrap">
              <span class="ai-status">Memory: saved on this device</span>
              <span class="ai-status ai-status--dot">Live answers</span>
            </div>
            <div class="ai-toolbar-actions">
              <button class="ai-clear" type="button" id="clear-chat">Clear chat</button>
              <button class="ai-close" type="button" id="close-chat" aria-label="Close AI chat">Close</button>
            </div>
          </div>

          <div class="ai-log" id="chat-log" aria-live="polite"></div>

          <form class="ai-input" id="chat-form">
            <label class="ai-label" for="chat-message">Ask about posts, photography, or reflections</label>
            <div class="ai-input-row">
              <textarea id="chat-message" rows="2" placeholder="What themes keep showing up in my writing?" required></textarea>
              <button type="submit">Send</button>
            </div>
            <p class="ai-hint">Your messages stay on this device. Responses are generated on-demand.</p>
          </form>
        </div>
      </div>
    </section>
  </main>

  <script>
    const STORAGE_KEY = "qjn_ai_chat";
    const log = document.getElementById("chat-log");
    const form = document.getElementById("chat-form");
    const input = document.getElementById("chat-message");
    const clearBtn = document.getElementById("clear-chat");

    function createLinkedText(text) {
      const container = document.createElement("span");
      const markdownLink = /\[([^\]]+)\]\((https?:\/\/[^\s)]+|\/[^\s)]+)\)/g;
      const urlPattern = /\bhttps?:\/\/[^\s]+/g;

      let lastIndex = 0;
      let match;

      while ((match = markdownLink.exec(text)) !== null) {
        const [full, label, href] = match;
        if (match.index > lastIndex) {
          container.appendChild(document.createTextNode(text.slice(lastIndex, match.index)));
        }

        const link = document.createElement("a");
        link.href = href;
        link.textContent = label;
        if (/^https?:\/\//i.test(href)) {
          link.rel = "noopener";
          link.target = "_blank";
        }
        container.appendChild(link);
        lastIndex = match.index + full.length;
      }

      if (lastIndex < text.length) {
        container.appendChild(document.createTextNode(text.slice(lastIndex)));
      }

      const childNodes = Array.from(container.childNodes);
      container.textContent = "";
      childNodes.forEach((node) => {
        if (node.nodeType === Node.TEXT_NODE) {
          const parts = node.textContent.split(urlPattern);
          const matches = node.textContent.match(urlPattern) || [];
          parts.forEach((part, idx) => {
            if (part) container.appendChild(document.createTextNode(part));
            const url = matches[idx];
            if (url) {
              const link = document.createElement("a");
              link.href = url;
              link.textContent = "link";
              link.rel = "noopener";
              link.target = "_blank";
              container.appendChild(link);
            }
          });
        } else {
          container.appendChild(node);
        }
      });

      return container;
    }

    function cleanForSpeech(text) {
      const withoutMarkdownLinks = text.replace(/\[([^\]]+)\]\((https?:\/\/[^\s)]+|\/[^\s)]+)\)/g, "$1");
      return withoutMarkdownLinks.replace(/\bhttps?:\/\/[^\s]+/g, "").replace(/\s+/g, " ").trim();
    }

    function render(messages) {
      log.innerHTML = "";
      messages.forEach((msg, index) => {
        const row = document.createElement("div");
        row.className = `ai-bubble ai-bubble--${msg.role}`;
        const textEl = document.createElement("p");
        textEl.className = "ai-bubble-text";
        if (msg.role === "assistant" && msg.text && msg.text !== "Thinking...") {
          textEl.appendChild(createLinkedText(msg.text));
        } else {
          textEl.textContent = msg.text;
        }
        row.appendChild(textEl);

        if (msg.role === "assistant" && msg.text && msg.text !== "Thinking...") {
          const controls = document.createElement("div");
          controls.className = "ai-bubble-controls";
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "ai-tts";
          btn.dataset.index = String(index);
          btn.textContent = "Listen";
          controls.appendChild(btn);
          row.appendChild(controls);
        }

        log.appendChild(row);
      });
      log.scrollTop = log.scrollHeight;
    }

    function loadMessages() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        return raw ? JSON.parse(raw) : [];
      } catch (e) {
        return [];
      }
    }

    function saveMessages(messages) {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(messages));
    }

    const messages = loadMessages();
    render(messages);

    async function sendMessage(payloadMessages) {
      const response = await fetch("/api/ask", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ messages: payloadMessages }),
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(errorText || "Request failed");
      }

      const data = await response.json();
      return data.reply || "Sorry, I couldn't generate a response.";
    }

    const openBtn = document.getElementById("open-chat");
    const closeBtn = document.getElementById("close-chat");

    if (openBtn) {
      openBtn.addEventListener("click", () => {
        document.body.classList.add("ai-chat-open");
        setTimeout(() => {
          input.focus();
          input.scrollIntoView({ behavior: "smooth", block: "center" });
        }, 150);
      });
    }

    if (closeBtn) {
      closeBtn.addEventListener("click", () => {
        document.body.classList.remove("ai-chat-open");
      });
    }

    input.addEventListener("focus", () => {
      document.body.classList.add("ai-chat-open");
      setTimeout(() => {
        input.scrollIntoView({ behavior: "smooth", block: "center" });
      }, 150);
    });

    async function requestSpeech(text) {
      const response = await fetch("/api/tts", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ text: cleanForSpeech(text) }),
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(errorText || "TTS request failed");
      }

      const blob = await response.blob();
      return URL.createObjectURL(blob);
    }

    log.addEventListener("click", async (event) => {
      const btn = event.target.closest(".ai-tts");
      if (!btn) return;
      const index = Number(btn.dataset.index);
      const msg = messages[index];
      if (!msg || msg.role !== "assistant") return;

      btn.disabled = true;
      btn.textContent = "Loading...";
      try {
        const audioUrl = await requestSpeech(msg.text);
        const audio = new Audio(audioUrl);
        audio.addEventListener("ended", () => {
          URL.revokeObjectURL(audioUrl);
        });
        audio.play();
        btn.textContent = "Playing";
      } catch (err) {
        btn.textContent = "Listen";
      } finally {
        btn.disabled = false;
      }
    });

    form.addEventListener("submit", async (event) => {
      event.preventDefault();
      const text = input.value.trim();
      if (!text) return;
      document.body.classList.add("ai-chat-open");
      messages.push({ role: "user", text });
      const payloadMessages = messages.map((msg) => ({
        role: msg.role,
        content: msg.text,
      }));
      const pendingIndex = messages.push({ role: "assistant", text: "Thinking..." }) - 1;
      render(messages);
      saveMessages(messages);
      input.value = "";
      input.focus();

      try {
        const reply = await sendMessage(payloadMessages);
        messages[pendingIndex].text = reply;
      } catch (err) {
        messages[pendingIndex].text = "Sorry, something went wrong. Please try again.";
      }

      render(messages);
      saveMessages(messages);
    });

    clearBtn.addEventListener("click", () => {
      if (!confirm("Clear this chat from your device?")) return;
      messages.length = 0;
      saveMessages(messages);
      render(messages);
    });
  </script>
  <script src="/assets/nav.js"></script>
</body>
</html>
